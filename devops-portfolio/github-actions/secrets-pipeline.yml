# github-actions/secrets-pipeline.yml: Secrets Management Workflow Example

name: ðŸ”‘ Secure Secret Injection Demo

on:
  # Manual trigger to control when this sensitive workflow runs
  workflow_dispatch:
    inputs:
      deployment_target:
        description: 'Environment to deploy to (e.g., dev, prod)'
        required: true
        default: 'dev'
      secret_name:
        description: 'Name of the secret to fetch from Key Vault'
        required: true
        default: 'database-connection-string'

permissions:
  contents: read
  id-token: write # Required for Azure login via OIDC to access Key Vault

env:
  AZURE_KEY_VAULT_NAME: portfolio-prod-kv # The name of your Key Vault

jobs:
  secure_deployment:
    runs-on: ubuntu-latest
    
    environment: ${{ github.event.inputs.deployment_target }} # Uses the input to define the environment

    steps:
      - name: â¬‡ï¸ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ” Azure Login (via OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          
      - name: ðŸ“¥ Fetch Secret from Azure Key Vault
        id: getsecret
        # The 'azure/keyvault-action' is an officially supported action for secret retrieval
        uses: azure/keyvault-action@v2
        with:
          keyvault: ${{ env.AZURE_KEY_VAULT_NAME }}
          secrets: |
            ${{ github.event.inputs.secret_name }}
          # The secrets are exposed as output variables for the step
      
      - name: ðŸ“ Use Secret in Deployment Configuration
        # This step simulates using the fetched secret (database connection string)
        # to configure an application or inject it into a deployment manifest.
        # CRITICAL: DO NOT echo the secret to logs in a real workflow! 
        # We use a placeholder here for demonstration purposes only.
        run: |
          # 1. Access the secret using the output variable from the previous step
          DB_CONN_STRING="${{ steps.getsecret.outputs[github.event.inputs.secret_name] }}"
          
          # 2. Safely Mask the secret in the logs 
          echo "::add-mask::${DB_CONN_STRING}"
          
          # 3. Simulate Configuration File Creation
          echo "Writing DB Connection string to config file..."
          echo "DATABASE_URL=${DB_CONN_STRING}" > application-config.env
          
          # 4. Simulate Deployment with the Config
          echo "Starting deployment to ${{ github.event.inputs.deployment_target }}..."
          # Replace this with an actual deployment command (e.g., kubectl apply, Helm install)
          ./deploy-script.sh --config-file application-config.env

      - name: ðŸ§¹ Clean up local configuration file
        # Best practice: Remove the configuration file containing the secret immediately
        if: always()
        run: rm -f application-config.env
        
      - name: âœ… Verify Secret Usage
        run: echo "Deployment complete. Secret was successfully injected and used securely."
